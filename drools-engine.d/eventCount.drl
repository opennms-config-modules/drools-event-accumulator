package org.opennms.netmgt.correlation.drools;

import java.util.Date;

import org.opennms.netmgt.correlation.drools.DroolsCorrelationEngine;
import org.opennms.netmgt.xml.event.Event;
import org.opennms.netmgt.xml.event.Parm;
import org.opennms.netmgt.model.events.EventBuilder;
import org.opennms.netmgt.model.events.EventUtils;

global org.opennms.netmgt.correlation.drools.DroolsCorrelationEngine engine;
global org.slf4j.Logger LOG;

global java.lang.Integer EVENT_COUNT;
global java.lang.Long EVENT_INTERVAL;
global java.lang.String UEI;

rule "Event received, create a flap timer if we dont have one"
    salience 100
    when
        $e : Event( $uei : uei, $nodeid : nodeid, $ipAddr : interface, $svcName : service )
        not $flap : Flap(nodeid == $nodeid, ipAddr == $ipAddr, svcName == $svcName, locationMonitor == -1 )
    then
        LOG.info( "Got an event: " + $uei );
        insert ( createFlap(engine, $nodeid, $ipAddr, $svcName, -1, EVENT_INTERVAL )); 
end

rule "Start a new flap count if we don't have one"
    salience 100
    when
        $e : Event( $uei : uei, $nodeid : nodeid, $ipAddr : interface, $svcName : service )
        $flap : Flap(nodeid == $nodeid, ipAddr == $ipAddr, svcName == $svcName, locationMonitor == -1 )
        not FlapCount( nodeid == $nodeid, ipAddr == $ipAddr, svcName == $svcName, locationMonitor == -1 )
    then
        insert( new FlapCount( $nodeid, $ipAddr, $svcName, -1 ) );
end

rule "start counting events"
    // Counter starts set to 1, so we want to increment after we've checked the count
    salience -100
    when
        $e : Event( $uei : uei, $nodeid : nodeid, $ipAddr : interface, $svcName : service )
        $flap : Flap(nodeid == $nodeid, ipAddr == $ipAddr, svcName == $svcName, locationMonitor == -1 )
        $eventCount : FlapCount( nodeid == $nodeid, ipAddr == $ipAddr, svcName == $svcName, locationMonitor == -1, $count : count )
    then
        modify( $eventCount ) {
            // FlapCount starts with a count of 1, so we only need to increment after the first one
            increment();
        }
        LOG.info( $uei + " count(" + $count + ")");
        delete( $e ); // don't keep processing since we've pre-incremented the count
end

rule "retract timer-expired counters"
    when
        $flap : Flap( $nodeid : nodeid, $ipAddr : ipAddr, $svcName : svcName, locationMonitor == -1, $timerId : timerId )
        $expiration: TimerExpired( id == $timerId )
        $eventCount : FlapCount( nodeid == $nodeid, ipAddr == $ipAddr, svcName == $svcName,  locationMonitor == -1 )
    then
        LOG.info( "Counter for " +$nodeid + ":" + $ipAddr + " has expired after " + EVENT_INTERVAL + "ms. ");
        delete( $flap );
        delete( $eventCount );
        delete( $expiration );
end

rule "flap count exceeded, send rollup event"
    when
        $eventCount : FlapCount( $nodeid : nodeid, $ipAddr : ipAddr, $svcName : svcName, locationMonitor == -1, alerted == false, count >= ( EVENT_COUNT ) )
        $e : Event()
    then
        sendRollupEvent( engine, $e, EVENT_COUNT, EVENT_INTERVAL );
        LOG.info("Event count(" + EVENT_COUNT  + ") exceeded for " + $e.getUei() + ", sending rollup event");
        modify( $eventCount ) {
            setAlerted( true );
        }
end

//
// Builds the rollup event to emit when the count is exceeded
//
function void sendRollupEvent(DroolsCorrelationEngine engine, Event e, Integer count, Long interval) {
    EventBuilder bldr = new EventBuilder(e.getUei() + "/Rollup", "DroolsEventAccumulator")
        .setNodeid(e.getNodeid())
        .setInterface(e.getInterfaceAddress())
        .setService(e.getService());
        copyParms(e, bldr);
        bldr.addParam("rolledUpUEI", e.getUei())
        .addParam("eventCount", count)
        .addParam("interval", interval);
    engine.sendEvent(bldr.getEvent());
}

//
// Creates the Flap object, which has the timer we need
//
function Flap createFlap(DroolsCorrelationEngine engine, Long nodeid, String ipAddr, String svcName, Integer locationMonitor, Long eventInterval) {
    return new Flap( nodeid, ipAddr, svcName, locationMonitor, engine.setTimer( eventInterval ) );
}

//
// Copy parms from the last event into the Rollup event
//
function void copyParms(Event sourceEvent, EventBuilder targetEventBuilder) {
    for (Parm p : sourceEvent.getParmCollection()) {
        targetEventBuilder.addParam(p);
    }
}
