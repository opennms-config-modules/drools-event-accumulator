package org.opennms.netmgt.correlation.drools;

import java.util.Date;

import org.opennms.netmgt.correlation.drools.DroolsCorrelationEngine;
import org.opennms.netmgt.xml.event.Event;
import org.opennms.netmgt.xml.event.Parm;
import org.opennms.netmgt.model.events.EventBuilder;
import org.opennms.netmgt.model.events.EventUtils;

global org.opennms.netmgt.correlation.drools.DroolsCorrelationEngine engine;
global org.slf4j.Logger LOG;

global java.lang.Integer EVENT_COUNT;
global java.lang.Long EVENT_INTERVAL;
global java.lang.String UEI;

//
// When we get a new event, create a 'Flap' object with a timer
// since interface traps (or oper status poll) could refer to an interface without an IP
// or come with event 'interface' of the loopback, we abuse the ipAddr field and add
// parm values to it to keep the timer unique per interface
//
rule "Event received, create a flap timer if we dont have one"
    salience 100
    when
        $e : Event( $uei : uei, $nodeid : nodeid, $ipAddr : interface, $svcName : service, $ifname : getParm("ifName"), $snmpifname : getParm("snmpifname") )
        not $flap : Flap(nodeid == $nodeid, ipAddr == $ipAddr+"_"+$snmpifname+"_"+$ifname, svcName == $svcName, locationMonitor == -1 )
    then
        LOG.info( $uei + " " + $ipAddr+"_"+$snmpifname+"_"+$ifname );
        insert ( createFlap(engine, $nodeid, $ipAddr+"_"+$snmpifname+"_"+$ifname, $svcName, -1, EVENT_INTERVAL ));
end

//
// After we've created a 'Flap' object with a timer, we also need to create a 'FlapCount'
// object to hold the number of times we've seen the event while the timer was active.
// As before, we use parm values to help with traps/oper status polling uniqueness
// A new counter starts with a value of 1, so we increment after we do other processing.
//
rule "Start a new flap count if we don't have one"
    salience 100
    when
        $e : Event( $uei : uei, $nodeid : nodeid, $ipAddr : interface, $svcName : service, $ifname : getParm("ifName"), $snmpifname : getParm("snmpifname") )
        $flap : Flap(nodeid == $nodeid, ipAddr == $ipAddr+"_"+$snmpifname+"_"+$ifname, svcName == $svcName, locationMonitor == -1 )
        not FlapCount( nodeid == $nodeid, ipAddr == $ipAddr+"_"+$snmpifname+"_"+$ifname, svcName == $svcName, locationMonitor == -1 )
    then
        insert( new FlapCount( $nodeid, $ipAddr+"_"+$snmpifname+"_"+$ifname, $svcName, -1 ) );
end

//
// When a timer expires, we remove the Flap and FlapCount objects. Since we're setting $ipAddr
// from the Flap object, we don't need to do anything special to get the string with parm values
//
rule "retract timer-expired counters"
    when
        $flap : Flap( $nodeid : nodeid, $ipAddr : ipAddr, $svcName : svcName, locationMonitor == -1, $timerId : timerId )
        $expiration: TimerExpired( id == $timerId )
        $eventCount : FlapCount( nodeid == $nodeid, ipAddr == $ipAddr, svcName == $svcName,  locationMonitor == -1 )
    then
        LOG.info( "Counter for " +$nodeid + ":" + $ipAddr + " has expired after " + EVENT_INTERVAL + "ms. ");
        delete( $flap );
        delete( $eventCount );
end

//
// Check the eventCount and see if we've crossed the threshold. We extract parm values from
// the event as with the other rules to find a unique eventCount for an uei+interface
//
rule "flap count exceeded, send rollup event"
    when
        $e : Event( $uei : uei, $nodeid : nodeid, $ipAddr : interface, $svcName : service, $ifname : getParm("ifName"), $snmpifname : getParm("snmpifname") )
        $eventCount : FlapCount( nodeid == $nodeid, ipAddr == $ipAddr+"_"+$snmpifname+"_"+$ifname, svcName == $svcName, locationMonitor == -1, alerted == false, count >= ( EVENT_COUNT ) )
    then
        sendRollupEvent( engine, $e, EVENT_COUNT, EVENT_INTERVAL );
        LOG.info("Event count(" + EVENT_COUNT  + ") exceeded for " + $uei + " " + $ipAddr+"_"+$snmpifname+"_"+$ifname + ", sending rollup event");
        modify( $eventCount ) {
            setAlerted( true );
        }
        // if EVENT_COUNT is 1 and EVENT_INTERVAL is long, we need to delete the event here, because otherwise the FlapCount will expire before we
        // increment and delete the event. This will cause us to send the Rollup over and over
        // We don't care if the $count is inaccurate during the rest of EVENT_INTERVAL because we've already sent the Rollup
        delete( $e );
end

//
// After other processing, we grab an event and associated FlapCount, increment it and
// then delete the event so it's not processed any more.
//
// lock-on-active shouldn't be necessary, but set it to be sure that we don't reactivate
// any rules based on incrementing the counter here (they should activate the next time
// an event comes in)
//
rule "increment event counter"
    salience -100
    lock-on-active true
    when
        $e : Event( $uei : uei, $nodeid : nodeid, $ipAddr : interface, $svcName : service, $ifname : getParm("ifName"), $snmpifname : getParm("snmpifname") )
        $eventCount : FlapCount( nodeid == $nodeid, ipAddr == $ipAddr+"_"+$snmpifname+"_"+$ifname, svcName == $svcName, locationMonitor == -1, $count : count )
    then
        modify( $eventCount ) {
            increment();
        }
        LOG.info( $uei + " " + $ipAddr+"_"+$snmpifname+"_"+$ifname + " count(" + $count + "++)" );
        delete( $e );
end

//
// Builds the rollup event to emit when the count is exceeded
//
function void sendRollupEvent(DroolsCorrelationEngine engine, Event e, Integer count, Long interval) {
    EventBuilder bldr = new EventBuilder(e.getUei() + "/Rollup", "DroolsEventAccumulator")
        .setNodeid(e.getNodeid())
        .setInterface(e.getInterfaceAddress())
        .setService(e.getService());
        copyParms(e, bldr);
        bldr.addParam("rolledUpUEI", e.getUei())
        .addParam("eventCount", count)
        .addParam("interval", interval);
    engine.sendEvent(bldr.getEvent());
}

//
// Creates the Flap object, which has the timer we need
//
function Flap createFlap(DroolsCorrelationEngine engine, Long nodeid, String ipAddr, String svcName, Integer locationMonitor, Long eventInterval) {
    return new Flap( nodeid, ipAddr, svcName, locationMonitor, engine.setTimer( eventInterval ) );
}

//
// Copy parms from the last event into the Rollup event
//
function void copyParms(Event sourceEvent, EventBuilder targetEventBuilder) {
    for (Parm p : sourceEvent.getParmCollection()) {
        targetEventBuilder.addParam(p);
    }
}
